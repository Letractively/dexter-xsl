#labels Phase-Deploy
  
= Dexter User Guide. =
  
==== author: Michael Dykman &lt;mdykman@gmail.com&gt; ====


 
 == The Dexter Environment ==
  
  _Here we describe the basic environment and the mechanisms which all modules share_
  
  === Running Dexter ===
  
  Dexter requires a minimum Java JRE 1.5. If you don't have an appropriate version already installed, one can be downloaded for most platforms at http://java.sun.com.Dexter can be run as a command line application or it can be embedded in an application, such as an IDE. No launch script is provided in this version. The command line syntax for dexter is the same on all platforms:

    {{{ 
		
		$ java -jar &lt;path-to-dexter-jar&gt; source1.ext [source2.ext ...]
		
		 }}}

    This will generate an XSL file with the name formed from the name of the input file with the 'xsl' extension added.

    {{{ 
		index.html        -&gt; index.html.xsl
		monthly-chart.svg -&gt; monthly-chart.svg.xsl
		
		 }}}

    Additional XSL files may be produced as the result of certain descriptor productions. See [ sub ] for an example.If the input document contains no dexter-defined attributes, the resulting stylesheet, when applied to any XML data set, will output the input document verbatim.If you're interested in embedding dexter, refer to the [ dexter api ] for information.
  
  === Terminology ===
  
  The document representing the desired target layout is termed the 'design document'. The design document is also sometimes referred to as the 'input document'.When a design document is embellished with dexter-defined attributes, the document is termed the 'source document'.The document which contains data to be formatted by an XSL stylesheet is termed the 'data document'The document which is created by applying an XSL stylesheet to a data document is termed the 'result document'. It should be emphasized that both the result document and the design document represent the same XML type.
  
  === Basics ===
  
  The default prefix, specified in dexter.properties, is 'xpl'. This may be changed if either it happens to conflict with your XML namespace or because you happen to feel like it.In this document, when describing dexter attributes, the convention will be to refer to them by the base name in the documentation and with the default prefix attached in code examples. ie. the attribute referred to as 'each' throughout the documentation is referred to as 'xpleach' in code examples.All dexter-defined attributes are logically removed from the source document are they are processed. No reference to them will be found in the XSL stylesheet nor in any result document. They are not physically removed from the input file.Note that the scope of any descriptor is identical to the scope of the element which contains it.
  
  === Id Attributes ===
  
  The source document may include a doctype definition which dexter will reflect but otherwise ignore, making no attempt at validation. As any given document's DTD or schema defines the id attributes for that XML document type, dexter uses an alternate mechanism.Dexter expects the value of the property 'dexter.node.id', defined in dexter.properties, to be a comma-delimited list of id-attribute names. By default, that list is defined as 'id,ID'. Some operations in dexter may require an element to have an id-attribute as a prerequisite.As the values of id-attributes should remain unique throughout any given document, dexter provides special handling. When an id attribute appears within an iterative context, the value is rendered with a suffix appropriate to the depth and position. If the reference occurs outside of any iterative context, the attribute's value remains unchanged.Note that if the id-attributes are not unique in the source document, some of dexter's productions will have undefined results.
  
  === Design Document ===
  
  Dexter accepts any well-formed XML as input. The specific XML type which is used as input entirely depends on the type of document you expect the resulting stylesheet to produce. If the goal is to generate XSL transforms which will create XHTML, then the design document must be an XHTML document. If the goal is to generate XSLT which will generate SVG, then the design document must be an SVG document. For day-to-day web projects, HTML is typically provided by a web designer and may require some tweaking to ensure that it is fully-compliant XHTML.In the same manner that id attributes are defined for a given DocType are typically specified in the DTD/Schema for that type, so are the entity references defined, such as &amp;quot; in XHTML. As dexter avoids DTD/schema validation (we do hideous things to the document during processing that a validating document would refuse), entity references are handled in a fairly low-tech way: they are simply passed through as literal data tokensDexter uses a simple entity resolver when parsing input documents at the command line. Specifically, it allows character entity references to pass through as literal text tokens in the output document. This preserves the references in the result document without resolving them. Doctype references return the empty string back to the parser, to avoid validation, but preserves the attributes in the result document through attributes in the xsl:output elementI have no intention of interfacing to the myriad options provided by 'tidy'. Instead, it is expected that a reasonably sophisticated developer can deal with task of ensuring that input documents are compliant XML, whether through an automated clean-up tool like 'tidy', or manually, as they prefer.
  
  === Examples ===
  
  The documentation for dexter resides in XML documents. It is formatted for human readability through stylesheets. If you are viewing this in XHTML in a standard web browser, this is likely stylesheet 'docster.html.xsl' which was generated from the dexter source file [ docster.html ] . When docster.html is viewed through a standard HTML browser, it looks exactly like what it is: a minimal skeleton document, integrating style elements with sample text, just as a designer might provide. View the source of docster.html and you will find that it has been embellished with 'xpl' attributes which describe the relationship between that document and an XML data document.If you are reading this documentation in Wiki format, the wiki-text was prepared by applying the stylesheet 'wikster.xml.xsl' to the XML. This stylesheet was generated from the dexter source file [ wikster.xml ] .
  
  === Output Document ===
  
  The output document is named by appending '.xsl' extension. to the input file name ie. source document 'index.html' will produce an output document name 'index.html.xsl'.Processing a source document with dexter may result in more than one stylesheet being generated.The default encoding is 'UTF-8' and I have done very little (IE. nothing) to investigate it's use with other character encodings.
  
  === Dexter and Paths ===
  
  Many dexter productions accept data path arguments. Dexter paths are based on a modified data-path notation similar to XPath but, in the authors opinion, not quite as ugly and a little more intuitive. Attributes, specified in XPath by '@', are indicated with ':'. in dexterity. The '@' operator is instead adopted by dexterity to introduce the path function suffix. The variable-depth path, notated in XPath as './/', dexter adopts the ant-inspired '**' instead.Other differences arise from the fact that dexter only exposes a tiny sub-set of XSL functionality. It is the author's assertion this comprises that subset of XSL which we actually need to accomplish everyday tasks. It is expected that extraordinary tasks, where they cannot be readily generalized and graduated into the dexterity base, may be accomplished by implementing custom descriptors. See the [ API Documentation ] for further information about this.Dexterity paths are always evaluated in context. The default context path is defined as '/' at the beginning of each input document. Path context is modified by the 'env' and 'each' operators. The modification applies to the scope of the element in which it is defined. Dexterity paths which begin with '/' (after prefix operators have been evaluated) are treated as absolute, otherwise they are mapped relative to current context. Some path examples:A data path expression is considered unresolved it cannot locate a data item in the context of the current data document.Some path examples:

    {{{ 
   */metadata/author
   /**/customers/customer:preferred
   friend/../:type
       }}}

    
  
  === Operators ===
  
  Many dexterity descriptors accept operators which modify a descriptors behavior. There are three operators currently defined, two prefix operators and one post-fix operator.The 'imperative' operator '!' is used as a prefix in many descriptor arguments. Where it occurs, it is usually the first character in the expression. It's meaning is contextual. These meanings will be explained in the documentation for each relevant descriptor.The 'child' operator '#' is used as a prefix to 'each', 'sub' and 'if'. It causes those descriptor's actions to be applied to the set of children, rather than to the element itself.The operator '@' is used as a suffix to a path to introduce a path-function expression. It is dealt with in detail in the next chapter.
  
  === Path Functions ===
  
  When the path-function operator '@' appears as the first path element in an expression (after prefix operators), a path of '.' is implied. The syntax of a path-function suffix is as follows:

    {{{ 
  '@' '!' &lt;function-name&gt; [ ':' &lt;argument&gt; ]
       }}}

    dexter.properties defines path functions under the key dexter.path.function.&lt;function-name&gt;, the value of which is the fully-qualified name of a class implementing the PathFunction interface. The details of creating user-defined path-functions are found in the [ Dexter API ] . There are four predefined path-functions in dexter.@!cmp-name:&lt;argument&gt; - used in test contexts (if, case). It generates an XPath expression which evaluates to true when the name of the current node of the path specified on the left matches the argument.As cmp-name is expected to be frequently utilized, it supports an abbreviated notation: @&lt;argument&gt;

    {{{ 
        &lt;div xpleach="thing/*"&gt;
          &lt;p xplcase="@!cmp-name:foo&gt;
        &lt;!-- render thing/foo --&gt;
          &lt;/p&gt;
          &lt;p xplcase="@bar&gt;
        &lt;!-- render thing/bar --&gt;
          &lt;/p&gt;
        &lt;/div&gt;
       }}}

    @!name - used in text evaluation contexts (value, attr).It generates an XPath expression which evaluates to the node name the current node of the path specified on the left.@!istext - used in test contexts. It generates an XPath expression which evaluates to true when the current node of the path specified on the left is a text node.

    {{{ 
  &lt;pre xplcase="@!istext" xplvalue="."&gt;
  &lt;!-- render text node literally --&gt;
    ...
  &lt;/p&gt;
  &lt;div xpldefault=""&gt;
  &lt;!-- handle whatever else --&gt;
    ...
  &lt;/div&gt;
       }}}

    @!text - used in iterator contexts (each). It generates an XPath expression which create a data axis containing the text node children of the path expression specified on the left.

    {{{ 
      &lt;p xpleach="link|@!text"&gt;
      &lt;!-- convert link to anchor --&gt;
         &lt;a xplcase="@link" href="#" xplattr="href:url" xplvalue="."&gt;ipsum lorum&lt;/a&gt;
      &lt;!-- handle the fall-through text nodes --&gt;
         &lt;span xpldefault=""&gt;ipsum lorum&lt;/span&gt;
    
      &lt;/p&gt;
       }}}

    
 
 == Dexterity ==
  
  _Here is reference information for the user who wishes to use dexterity to create XSL transforms from existing XML and HTML documents.__Generally speaking, if your productions are defined exclusively by dexterity descriptors (excepting 'ccpy'), a valid design document results in a stylesheet which will render equally valid result documents. There are exceptions to this, which will be discussed in further detail eventually._
  
  === env ===
  
  'env' - sets the data path context for other dexterity descriptors operating within it's scope. The path it sets is evaluated in the context of the current path such that absolute paths will be set absolutely, relative paths will be resolved in the current context. 'env' does not generate any XSLT productions. It does not admit any prefix operators. 'each' sets the context path in a similar way.

    {{{ 
   &lt;div xplenv="**/customers"&gt;
      ...
   &lt;/div&gt;
   		 }}}

    
  
  === value, ccpy ===
  
  Dexterity is equipped with two descriptors which map data into the child nodes of the source element: 'value' and 'ccpy'.'value' replaces all child nodes of the current source element with the text content of the data node specified by the path. If the imperative operator '!' is specified, the child nodes of the current source element will be retained as the default value in the event the data path specified is unresolvable. When '!' is not specified and the data path is unresolvable, no child node will be inserted in the output document and the current source element will be rendered as an empty element. For all practical purposes, CDATA nodes are treated as text nodes throughout.

    {{{ 
   in the source document: 
      &lt;title xplvalue="*/metadata/title"&gt;This will be thrown away&lt;/title&gt;
         ...
      &lt;div xplenv="*/metadata"&gt;
         Title: &lt;h3  xplvalue="title"&gt;Throw Me Away Title&lt;/h3&gt;
         Author: &lt;span  xplvalue="!author"&gt;Michael Dykman&lt;/span&gt;
      &lt;/div&gt;
				
   produces an XSL transformation which will render this XML data fragment:
      &lt;data&gt;
         &lt;metadata&gt;
            &lt;title&gt;The Castle&lt;/title&gt;
            &lt;author&gt;Franz Kafka&lt;/author&gt;
            ...						
   into this:
      &lt;title &gt;The Castle&lt;/title&gt;
         ...
      &lt;div&gt;
         Title: &lt;h3 &gt;The Castle&lt;/h3&gt;
         Author: &lt;span&gt;Franz Kafka&lt;/span&gt;
      &lt;/div&gt;
       }}}

    'ccpy' is similar to 'value' except that, instead of substituting text values, it will export all children of the data node replacing all children of the current source element. If the imperative operator '!' is specified, the child nodes of the current source element will be retained as the default value.When the objective is to produce XHTML over-reliance on 'ccpy' should be considered a hack. While it can be useful to implement containers for pre-formatted content, using it as a general habit implies that the application has formatting details interpolated with the data stream which is exactly the kind of thing we are trying to avoid. Still, there are cases where it can be useful in transitional strategies or when outputting stylesheets where input and output types share common structures.

    {{{ 
   &lt;!-- in the source: -- --&gt;
   &lt;div xplccpy="!user/essay"&gt;
   &lt;h1&gt;The user is reticent on this topic&lt;/h1&gt;
      ...
   &lt;/div&gt;
   		
   this will replace the content of the &lt;div&gt; with the child content of 
   user/essay.
					 
   a data document might look like
   &lt;user ...&gt;
   ...
      &lt;essay&gt;
         &lt;h1&gt;the story of my life&lt;/h1&gt;
         &lt;p&gt;In a small shack built on the bayous of Louisiana...
         &lt;/p&gt;
         ...
      &lt;essay&gt;
   &lt;/user&gt;
   	 }}}

    
  
  === attr ===
  
  'attr' - accepts a space-delimited list of expressions each of which is prefixed with an attribute assignment expression of the form "attribute-name ':' expression". Each expression causes the attribute named on the left-hand side of the expression to be assigned the value of the expression on the right.For a simple expression, one not containing '{', the entire expression is evaluated as a data path. The text content of the node described by the data path is assigned to the named attribute.

    {{{ 
   &lt;a href="www.fake.com" xplattr="href:homepage"&gt;click here&lt;/a&gt;

   &lt;img src="default-image.jpg" width="40" height="40"
      xplattr="src:image width:image:width height:image:height"/&gt;
   maps data from the example image element into the attributes of the img element
   &lt;image width="60" height="40"&gt;john.jpg&lt;/image&gt;
   	 }}}

    When an expression does contain '{', it is termed a compound expression and the following rules are applied. Each '{' character expects a closing '}' character. Nesting is not permitted. The contents of the matched braces '{ }' are evaluated as a data path expression. All characters outside the matched braces are treated as literal content. The text content of each node described in the expression is substituted for the braced expression and the resulting value is assigned to the named attribute. The value is rendered if and only if all data path components can be resolved in the current data context. There currently is no support for whitespace in literal content.

    {{{ 
   &lt;a href="mailto://admin@nowhere.com" xplattr="href:mailto://{email}"&gt;email me&lt;/a&gt;
      
   &lt;!-- clickable TOC --&gt;
   &lt;a href="#" xplattr="href:#{title}" xplvalue="title&gt;click here&lt;/a&gt;
   &lt;!-- where the destination might be defined as  --&gt;
   &lt;a name="disposeme" xplattr="title"&gt;&lt;h3 &gt;Chapter Title&lt;/h3&gt;&lt;/a&gt;
	
   &lt;!-- turn image information into an img tag --&gt;
   &lt;!-- given a data document: --&gt;
   &lt;user ...&gt;
      &lt;profile&gt;
         &lt;image&gt;
         	&lt;name&gt;hank.jpg&lt;/name&gt;
         	&lt;height&gt;48&lt;/height&gt;
         	&lt;width&gt;62&lt;/width&gt;
         &lt;/image&gt;
      &lt;/profile&gt;
      ...
   &lt;/user&gt;

   &lt;!-- define the transformation.  the shown values of the src, width and height attributes
      are discarded to be replaced with the values from the data document --&gt;
   &lt;img src="default.jpg" width="50" height="50" 
      xplenv="profile/image"
      xplattr="src:/profile/images/{name} height:height width:width" /&gt;
    }}}

    If the expression is prefixed with the imperative operator '!' and the attribute to be written is specified in the source document, the value of that attribute is retained as a default value in the event that the data path specified is unresolvable in the data document. If an expression is unresolved, the default value will be supplied when it has been indicated, otherwise it is blank. When multiple data paths have been specified via compound notation, the default will be applied if any data path expression is unresolved.

    {{{ 
   &lt;a href="javascript:alert('a path component was absent from the data'); void(0);" 
      xplattr="href:!/files/{directory}/{filename}" xplvalue="!filename"&gt;click here&lt;/a&gt;
			 }}}

    
  
  === if, case..default ===
  
  Two mechanisms are provided for addressing conditional output: 'if' and the 'case'..'default' construct. Both 'if' and 'case' accept a delimited list of expressions. An expression which contains only a data path expression evaluates to true if the data path can be resolved in the current data context, otherwise it is false.Delimiters consist of spaces ' ' or pipes '|'. Space separators imply AND operations; pipes imply OR. All AND expressions are resolved before any OR expressions are evaluated. Empty test lists are illegal. Expression grouping via braces is not permitted.'if' - decides whether the current source node and it's children are to be rendered into the target document or not. There are no external side-effects.

    {{{ 
   &lt;!-- render the div if the current data node contains the 'preferred' attribute --&gt;
   &lt;div id="userinfo" xplif=":preferred"&gt;
     ...
  &lt;/div&gt;

   &lt;!-- if the current data node is named 'code', render the tag allowing the xplvalue 
       expression to define it's text content --&gt;
   &lt;pre xplif="@code" xplvalue="."/&gt;
       }}}

    Prefixing the imperative operator '!" to a test expression negates the boolean value.When the argument to 'if' is prefixed with the child operator '#', the effect is to produce an empty element, attributes intact, when the expression list evaluates to false.'case'..'default' - provides if/elseif/else chained logic. When a 'case' descriptor is discovered in the input document, a block is determined by scanning forward through contiguous elements (which need not be of the same element type), appending each subsequent 'case' to the exclusivity block.The forward-scan is terminated either when an element decorated with 'default' is encountered (which is added to the block as the unconditional fall-through), when an element with neither 'case' nor 'default' is encountered (which is not added to the block), or when no more contiguous elements can be found. The 'default' is therefore optional in this construct.The expression lists for each 'case' are evaluated in document order. The first expression list which evaluates to true causes that source node to be rendered into the target document and block evaluation is terminated. If no 'case' expression evaluates to true, the 'default' element, if any, is rendered into the output document. If no 'case' expression evaluates to true and no 'default' is specified, then the block evaluation results in no output.Usage examples for 'case'..'default' are provided along with the examples for 'each'
  
  === each ===
  
  accepts a data path, optionally prefixed with the apply-to-children '#' operator. It causes either the source element or the set of it's children to be repeated once for each element in the set described by the data path. It has the additional effect of setting the context path with the same semantics as 'env'.

    {{{ 
   &lt;!-- as specified here with '#', this will produce one table with many rows.  
      without the'#' operator, it would produce many tables instead.
   --&gt;
   &lt;table xpleach="#**/customers/customer"&gt;
      &lt;tr&gt;
         &lt;td&gt;First Name&lt;/td&gt;&lt;td xplvalue="firstname"&gt;Tom&lt;/td&gt;
         &lt;td&gt;Last Name&lt;/td&gt;&lt;td xplvalue="lastname"&gt;Waits&lt;/td&gt;
      &lt;/tr&gt;
   &lt;/table&gt;

   &lt;!-- iterate through all element children of chapter, rendering a div 
      for each and using a case block for type-appropriate content. 
   --&gt;  
   &lt;div xpleach="chapter/*"&gt;
      &lt;div xplcase="@title"&gt;
      	&lt;a name="tag" xplattr="name:title" /&gt;
        &lt;h3 xplvalue="."&gt;my chapter&lt;/h3&gt;
      &lt;/div&gt;
      &lt;p xplcase="@para" xplvalue="."&gt;lorum ipsum&lt;/p&gt;
      &lt;pre xplcase="@code" xplvalue="."&gt;//code sample&lt;/pre&gt;
   &lt;/div&gt;
     }}}

    
  
  === uniq ===
  
  'uniq' is used to ensure that specified attribute values remain unique through a document, in the same manner as an id attribute. Attributes named in a 'uniq' expression are not id attributes but their values are subject to modification depending upon the iterative context.Note that, for both id attributes and uniq-designates, if the attributes are not unique in the source document, some of dexter's productions will have undefined results.

    {{{ 
   &lt;div xpleach="*/message/message"&gt;
   &lt;!--
   	this will ensure that the form's name attribute will have a unique value 
   	in each repetition. ie. myform-1,myform-2,...
   --&gt;
      &lt;form name="myform" xpluniq="name"&gt;
      ...
         &lt;input type="submit" value="read this" xplattr="value:message-{id}" /&gt;
      &lt;/form&gt;
   &lt;/div&gt;
    }}}

    
  
  === sub ===
  
  'sub' - accepts a data path, optionally prefixed with '#". It creates a separate XML stylesheet document which describes the current source node and it's children includes it in into the current stylesheet. That template is then invoked via an XSL 'apply-templates' call with a match attribute derived from the 'sub' data path. If the '#" prefix is specified, the sub-transform will describe the child nodes of the current element, instead of the element itself.'sub' requires an id-attribute to be defined, which becomes part of the name of the sub-transformation. If a 'sub' descriptor is discovered on an element with the id attribute set to 'messages' in an input document named 'index.html', it will generate an sub-transformation document named 'index-messages-xsl'.

    {{{ 
   &lt;!-- creates a sub Transform named 'messages' which describes the 
      current table element and invoke it via apply-templates --&gt;
   &lt;table id="messages" xplsub="**/messages"&gt;
       ...
   &lt;/table&gt;
     }}}

    Alternatively, the data path expression may be suffixed with a label explicitly indicating the name of a pre-existing XSL transform to be used instead. In this case, no external document is created and the external stylesheet is including into the current document.

    {{{ 
   &lt;!-- include the external template 'index-messages.xsl'
   	which has been defined in an input file name 
   	'index[.anything]' and invoke it via apply templates.
   	The contents of the current node are discarded.
   	--&gt;
   &lt;table xplsub="**/messages:index-messages"&gt;
      ...
   &lt;/table&gt;
		 }}}

    
  
  === ignore ===
  
  'ignore' - accepts an empty argument. Used to eliminate an element and it's children from output production. This is useful when a design document contains a sequence of examples of repeated content. The user typically will choose one (or more if 'case' is utilized) to describe the output and then apply 'ignore' to the unused elements rather removing them from the source. This assists us in maintaining the integrity of the design document, even as we mark it up as source for XSLT production.

    {{{ 
   &lt;div id="allcustomers" xpleach"#*/customers/customer"&gt;
    &lt;div&gt;
      account : &lt;span xplvalue="accountid"&gt;12345678&lt;/span&gt;&lt;br/&gt;
      name    : &lt;span xplvalue="lastname"&gt;Iverson&lt;/span&gt;, &lt;span xplvalue="firstname"&gt;Kenneth&lt;/span&gt;&lt;br/&gt;
    &lt;/div&gt;
    &lt;div xplignore=""&gt;
      account : &lt;span &gt;23456789&lt;/span&gt;&lt;br/&gt;
      name    : &lt;span &gt;Knuth&lt;/span&gt;, &lt;span &gt;Donald&lt;/span&gt;&lt;br/&gt;
    &lt;/div&gt;
    &lt;div xplignore=""&gt;
      account : &lt;span &gt;34567890&lt;/span&gt;&lt;br/&gt;
      name    : &lt;span &gt;Bachaus&lt;/span&gt;, &lt;span&gt;Jim&lt;/span&gt;&lt;br/&gt;
    &lt;/div&gt;
   &lt;/div&gt; 
      }}}

    
  
  === ghost ===
  
  'ghost' - accepts an empty argument. Used to eliminate an element from output production while retaining it's children. It's principal use is to allow an element node to act as a container for other dexter operations, without being represented in the result document.

    {{{ 
   &lt;!-- I need to splice in part of a phrase but I really don't want the &lt;span&gt;
     in the output.   --&gt;
   &lt;p xpleach"#*/friends/friend"&gt;
      My friend is &lt;span xplghost="" xplvalue="."&gt;some schmo&lt;/span&gt;&lt;br/&gt;
   &lt;/p&gt;
   &lt;!-- might produce this in the output document --&gt;
   &lt;p&gt;
      My friend is John&lt;br/&gt;
      My friend is Paul&lt;br/&gt;
      My friend is George&lt;br/&gt;
      My friend is Ringo&lt;br/&gt;
   &lt;/p&gt;
      }}}

    
 
 == Didi ==
  
  _Didi is the module responsible for XHTML functionality._
  
  === meta ===
  
  The meta attribute is linked to a DocumentEditor. It replaces the current node with a list of META elements with name/content pairs derived from the file named in the attribute value. Through this simple mechanism, we are able to maintain consistent meta tags throughout a document set.

    {{{ 
    &lt;META xplmeta="dexter.meta" name="keywords" content="example" /&gt;
     }}}

    The file 'dexter.meta' uses the standard format of a Properties file:

    {{{ 
 Rating=General
 Distribution=Global
 Robots=index, follow
 Generator=dexter-0.1.1-alpha (c) 2007,2008 Michael Dykman
 Keywords=XSL,XSLT,XHTML,XML,W3C,DocType,web,development,web-development,\
   tool,code-generation,convert,converter
 Description=Dexter is a tool for simplifying the production of XSL \
   stylesheets.
 Author=Michael Dykman &lt;michael@dykman.org&gt;
 Copyright=2007,2008 Michael Dykman
     }}}

    
  
  === data ===
  
  data employs a concise syntax to expose JavaScript arrays composed of data items and form elements. They are rendered as the value of an arbitrary attribute specified in the pretties file under the key 'dexter.didi.jsparam'. This value may be eval-uated by JavaScript to create anonymous data arrays. The default is to use the attribute 'jsdata' to contain the string.

    {{{ 
    dexter.didi.jsparam=data
     }}}

    This descriptor expects a space-delimited list of data definitions. Each definition begins with a name followed by a semi-colon and a value expression. There are 3 classes of value expression; an example of each is given below:

    {{{ 
 xpldata="field:$myform.field action:!reload id::id"
     }}}

    This will create an array containing three named items: field, action and id.'field:$myform.field' has a data value expression beginning with a '$' operator. This indicates that this item refers to a specific element of a named form and will construct a JavaScript expression which may be evaluated to determine the fields real-time value. It is required that named forms referenced by such expressions are always anointed by the dexterity 'uniq' descriptor. If this is not observed, invalid code may be generated.

    {{{ 
 document.forms["myform"].field.value
     }}}

    'action:!reload' the data value expression is prefixed with the now familiar imperative operator '!' which, in this case, means to treat the rest of the expression as a literal string.'id::id' the data value expression is not prefixed and is therefore treated as a dexter data path, in this case ':id'. Note that the first semi-colon is the name-separator, the second is part of the dexter path.. It is evaluated in context at document assembly and translated into a literal value is the data expression.Once assembled, the jsdata attribute (as specified in dexter.properties) of the current node is assigned a value which may be eval'ed by JavaScript as an anonymous Object. expression.

    {{{    
 xpldata="field:$myform.field action:!reload id::id"
 // may generate "jsdata" value (formatted here for readability) 
 { "id":'55', "action":'reload', 
         "field":document.forms["myform-4"].field.value };
     }}}

    The interface to those data items is flexible. You may give your node an 'id' attribute so that your JavaScript may readily navigate to it, or pass it to callback functions.

    {{{ 
  &lt;script&gt;
    function myfunc(el)
    {
      var exp = el.getAttribute("jsdata");
      var data = eval("new Object( " + exp + ");");
      alert("id=" + data.id);
      ...
    }
  &lt;/script&gt; 

  &lt;a href="#" onclick="myfunc(this);"
    xpldata="field:$myform.field action:!reload id::id"&gt;click here&lt;/a&gt;
     }}}

    

    ,, dexter (c) 2007, 2008 Michael Dykman Free for use under version 2.0 of the Artistic License. http://www.opensource.org/licences/artistic-license.php ,,
  