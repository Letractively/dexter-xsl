<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"><xsl:output doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN" doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd" encoding="UTF-8" indent="no" media-type="text/html" method="html">
<!-- generated by dexter from `../docs/docster.html'  -->
</xsl:output><xsl:template match="/"><!-- 
Examples of the data document may be found at

http://dexter-xsl.googlecode.com/svn/trunk/docs/index.xml
http://dexter-xsl.googlecode.com/svn/trunk/docs/dexter-api.xml
http://dexter-xsl.googlecode.com/svn/trunk/docs/dexter-user-guide.xml
http://dexter-xsl.googlecode.com/svn/trunk/docs/case-for-xsl.xml

There XML document form the core of dexter's documentation.  They can viewed in your
web browsers styled by the XSLT generated by this source document.

A quick and dirty skeleton of the data format is shown below
for quick reference
<doc>
    <copyright>(c) 2008</copyright>

	<title>A Title</title>
	<subtitle>The Whole Story</subtitle>
	<author>Some Guy</author>
	<overview>
		<para>document overview text.</para>
		...
	</overview>
	<references>
   		<reference>
     			<title>name of external doc</title>
     			<summary>summary of external doc</summary>
     			<url>index.xml</url>
   		</reference>
   		...
	</references>
	<section>
		<title>Section Title</title>
		<overview>
			<para>section overview text</para>
			...
		</overview>

		<chapter>
			<title>chapter title</title>
			<para>
				text text <link url="http://www.foo.com"> text
				...
			</para>
		</chapter>
		...
	</section>
	...
	
<doc>
--><!-- 
declare dexter-related attributes in thier default namespace..  
dexter does not care is you do so or not, but it will in any case
prevent them from being reflected in generated code.  

Please note that if you use an alternate namespace, you must set a property at the 
command line:
    $ dexter.sh -d=dexterity.namespace=myns input.html ...
 --><xsl:element name="html">
<xsl:element name="head">
<xsl:element name="style"><xsl:attribute name="type">text/css</xsl:attribute>
@import url("style.css");
</xsl:element>
<!--
  intial context is '/'
  
  dx:value
  replace the content of the 'title' tag with the text content of */title 

  REMEMBER: all path expressions refer to the data document, not to nodes within 
  the current document.  
 -->
<xsl:element name="title"><xsl:value-of select="*/title"/></xsl:element>
<!--
  dd:meta
  replace the currrent tag with a set of meta tags derived from data in the file dexter.meta 
 -->
<xsl:element name="meta"><xsl:attribute name="content">Global</xsl:attribute><xsl:attribute name="name">Distribution</xsl:attribute></xsl:element><xsl:element name="meta"><xsl:attribute name="content">Michael Dykman &lt;michael@dykman.org&gt;</xsl:attribute><xsl:attribute name="name">Author</xsl:attribute></xsl:element><xsl:element name="meta"><xsl:attribute name="content">2007,2008 Michael Dykman</xsl:attribute><xsl:attribute name="name">Copyright</xsl:attribute></xsl:element><xsl:element name="meta"><xsl:attribute name="content">General</xsl:attribute><xsl:attribute name="name">Rating</xsl:attribute></xsl:element><xsl:element name="meta"><xsl:attribute name="content">XSL,XSLT,XHTML,XML,W3C,DocType,web,development,web-development,tool,code-generation,convert,converter</xsl:attribute><xsl:attribute name="name">Keywords</xsl:attribute></xsl:element><xsl:element name="meta"><xsl:attribute name="content">Dexter is a tool for simplifying the production of XSL stylesheets.</xsl:attribute><xsl:attribute name="name">Description</xsl:attribute></xsl:element><xsl:element name="meta"><xsl:attribute name="content">dexter-0.1.6-beta (c) 2007,2008 Michael Dykman</xsl:attribute><xsl:attribute name="name">Generator</xsl:attribute></xsl:element><xsl:element name="meta"><xsl:attribute name="content">index, follow</xsl:attribute><xsl:attribute name="name">Robots</xsl:attribute></xsl:element>
</xsl:element>
<xsl:element name="body">
<xsl:element name="div"><xsl:attribute name="class">foo</xsl:attribute><xsl:element name="span"> <xsl:element name="a"><xsl:attribute name="name">TOP</xsl:attribute></xsl:element></xsl:element>
<xsl:element name="div">
<!--
  dx:value
  replace the content of the 'title' tag with the text content of */title 
  from the data document 
 -->
<xsl:element name="h1"><xsl:value-of select="*/title"/></xsl:element>
<!--
  dx:if
  if a node is found at the path */subtitle in the data document,
  	replace the content of the 'title' tag with the text content of */title
  if no node is found, this node will not be rendered 
  from the data document 
 -->
<xsl:if test="*/subtitle"><xsl:element name="h5"><xsl:value-of select="*/subtitle"/></xsl:element></xsl:if>
</xsl:element>

<xsl:element name="div"><xsl:attribute name="style">float: right; width: 35%</xsl:attribute>
<xsl:element name="div"><xsl:attribute name="style">clear: both; align: left; width: 100%;</xsl:attribute>

<xsl:element name="span"><xsl:attribute name="class">author</xsl:attribute><xsl:attribute name="style">width: 100% align : left;</xsl:attribute>author:
<!-- 
  dx:ghost
  remove the current element from output while performing all operaetions attached
  to that element. 
  
  The following expression will evaluate the dx:value expression, inserting
  the text value of */author from the data document but not outputing the span
  which it is contained in
 --> 
<xsl:value-of select="*/author"/>
</xsl:element></xsl:element>
<xsl:element name="br"/>

<!-- 
 dx:each
  iterate over the current element for each node found in the expression.
  this has the additional effect of setting the path context.
  
  in this case, it will generate a div for each element found in the data document
  at the path */references/reference. 
  relative path expressions oncountered within this element's children will be
  evaluated in the context */references/reference
  For example, the path expression 'title' is evaluated as
  the title element of the current reference element.
 --> 
 
<xsl:for-each select="*/references/reference"><xsl:element name="div"><xsl:attribute name="style">clear: both;</xsl:attribute>
<xsl:element name="div"><xsl:attribute name="style">padding-left: 5px; left-margin: 5px;</xsl:attribute>
<!--
  dx:attr
  rewrite an attribute values on the current node
  
  here, we render the text context of the url element of
  the current reference as the value of the href attribute 
 -->	
<xsl:element name="a"><xsl:attribute name="href"><xsl:value-of select="url"/></xsl:attribute><xsl:value-of select="title"/></xsl:element><xsl:element name="br"/>

<xsl:element name="div"><xsl:attribute name="style">left-margin: 5px;</xsl:attribute><xsl:value-of select="summary"/></xsl:element>
</xsl:element>
</xsl:element></xsl:for-each>
<!-- end of each -->


<!--
  dx:ignore
  ignore the current node and any embedded operations.
   
  this node is left in for cosmetic purposes as an example
  of what more than one reference looks like but is completely 
  ignored during XSL generation, as the preceeding dx:each 
  descriptor will handle all refernce nodes in the data document  
 -->



</xsl:element>

<xsl:element name="div"><xsl:attribute name="style">float: left; width: 55%</xsl:attribute>

<!--
  dx:env
  set the context path while performing no operation 
 -->
<xsl:element name="div"><xsl:attribute name="style">float: left; clear: both;</xsl:attribute>
<xsl:element name="h2"><xsl:attribute name="width">100%</xsl:attribute>Overview</xsl:element>
<xsl:element name="p">
<!--
   each para in */overview 
 -->
<xsl:for-each select="*/overview/para"><xsl:element name="i"><xsl:value-of select="."/></xsl:element></xsl:for-each>

</xsl:element>
</xsl:element>
<!-- end dx:env -->

<!--
  the path macro morethan is a core path macro.  it is defined in
  dexter.properties as

  	dexter.macro.morethan=count($path) > $arg
 
  therefore the expression is tranlated into the XPATH expression:
  
  		count(*/section) > 1
  		
  	as used in the following dx:if descriptor, it means that the table
  	of contents will only be rendered if the data document has more than 
  	one section.
  	 
 -->
<xsl:if test="count(*/section) &gt; 1"><xsl:element name="div"><xsl:attribute name="style">top-margin: 15px;</xsl:attribute>
<xsl:element name="h2">Table of Contents</xsl:element>
<xsl:element name="a"><xsl:attribute name="name">TOC</xsl:attribute></xsl:element>
<xsl:element name="div"><xsl:attribute name="style">left-margin: 30px;</xsl:attribute><xsl:for-each select="*/section"><xsl:element name="a"><xsl:attribute name="href"><xsl:choose><xsl:when test="title/text()"><xsl:text><![CDATA[#]]></xsl:text><xsl:value-of select="title"/></xsl:when><xsl:otherwise><xsl:text/></xsl:otherwise></xsl:choose></xsl:attribute><xsl:value-of select="title"/></xsl:element><xsl:element name="br"/>
</xsl:for-each></xsl:element>
</xsl:element></xsl:if>
<!-- end dx:if -->

</xsl:element>

</xsl:element>

<xsl:element name="div"><xsl:attribute name="style">clear: both</xsl:attribute>
<!--
create a div for each section, setting the context path 
 -->
<xsl:for-each select="*/section"><xsl:element name="div"><xsl:element name="a"><xsl:attribute name="name"><xsl:choose><xsl:when test="title/text()"><xsl:text/><xsl:value-of select="title"/></xsl:when><xsl:otherwise><xsl:text/></xsl:otherwise></xsl:choose></xsl:attribute></xsl:element>

<xsl:element name="h2"><xsl:attribute name="width">80%</xsl:attribute><xsl:value-of select="title"/></xsl:element>

<!--
  note the '#' sign at the start of the expression in dx:each.  it is used as 
  the child operator.       instead of rendering a div for each para found in
  the data document under */section/overview/, we render one 'div' tag and 
  iterate through the children. (note the enclosing dx:each context).
 -->
<xsl:if test="overview"><xsl:element name="div"><xsl:attribute name="width">60%</xsl:attribute><xsl:for-each select="overview/para">
<xsl:element name="p"><xsl:element name="i"><xsl:value-of select="."/></xsl:element></xsl:element>

</xsl:for-each></xsl:element></xsl:if>

<!-- 
  create one 'div' to contain all chpaters in the current section
  
  the expression in dx:attr is an example of a compound expression where
  element between the braces { } are treated as data paths and elements
  outside the braces are treated as literal.  Here it is used to 
  generate a table of links to each chapter in the section. The # sign,
  in the context of the dx:attr descriptor, has no special meaning and is
  interpreted literally.
-->
<xsl:element name="div"><xsl:attribute name="class">listing</xsl:attribute><xsl:for-each select="chapter"><xsl:element name="a"><xsl:attribute name="href"><xsl:choose><xsl:when test="../title/text() and title/text()"><xsl:text><![CDATA[#]]></xsl:text><xsl:value-of select="../title"/><xsl:text><![CDATA[-]]></xsl:text><xsl:value-of select="title"/></xsl:when><xsl:otherwise><xsl:text/></xsl:otherwise></xsl:choose></xsl:attribute>&gt; <xsl:value-of select="title"/></xsl:element><xsl:element name="br"/>
</xsl:for-each></xsl:element>
<xsl:element name="a"><xsl:attribute name="href">#TOC</xsl:attribute>&lt;&lt; Table of Contents</xsl:element><xsl:element name="br"/>
<xsl:element name="a"><xsl:attribute name="href">#TOP</xsl:attribute>&lt;&lt; Top</xsl:element><xsl:element name="br"/>

<!--
  now we render each chapter in the section, setting the context path. 
 -->
<xsl:for-each select="chapter"><xsl:element name="div"><xsl:attribute name="class">section</xsl:attribute>
<!--
   here we used the compound attribute to build the target for those same links 
 -->
<xsl:element name="a"><xsl:attribute name="name"><xsl:choose><xsl:when test="../title/text() and title/text()"><xsl:text/><xsl:value-of select="../title"/><xsl:text><![CDATA[-]]></xsl:text><xsl:value-of select="title"/></xsl:when><xsl:otherwise><xsl:text/></xsl:otherwise></xsl:choose></xsl:attribute></xsl:element>
<xsl:element name="h3"><xsl:value-of select="title"/></xsl:element>

<!--
create a div and iterate through it's children with each element 
under chapter  
 -->
<xsl:element name="div"><xsl:for-each select="*">
<!--
	dx:case
	similar to if, but expressions are evaluated between contiguous 
	tagged nodes, rendering the first which evaluates to true.
	in this case @para will be true if the current node is named 
	'para'. The next contiguous node in this chain tests for nodes
	name 'code'  
	
	the dx:each expression is evaluated in the context of the para node.
	With various nested dx:each expressions, the effective path within this
	tag and it's childeren is */section/chapter/para.  Both lnk nodes
	and text nodes will be combined into a signle cursor which will
	return those nodes in document order.  IT is by this mechanism that 
	link tags may be intermingled with raw text.
 -->
<xsl:choose><xsl:when test="local-name(.) = &quot;para&quot;"><xsl:element name="p"><xsl:for-each select="link|./text()">
<!-- an nested case..  the path expression return true if the current node is a text
node, in which case dx:value is applied replacing the content of this element
with the text node from the data document 
 -->
<xsl:choose><xsl:when test="./self::text()"><xsl:value-of select="."/></xsl:when><xsl:when test="local-name(.) = &quot;link&quot;"><xsl:element name="a"><xsl:attribute name="href"><xsl:value-of select="@url"/></xsl:attribute><xsl:value-of select="."/></xsl:element></xsl:when></xsl:choose></xsl:for-each></xsl:element></xsl:when><xsl:when test="local-name(.) = &quot;code&quot;"><xsl:element name="div"><xsl:element name="pre"><xsl:attribute name="style">width: 80%;</xsl:attribute><xsl:value-of select="."/></xsl:element></xsl:element></xsl:when></xsl:choose></xsl:for-each></xsl:element>
<!-- outer case chain terminates for want of a continuation -->

<xsl:element name="div"><xsl:attribute name="style">text-align: center</xsl:attribute><xsl:element name="a"><xsl:attribute name="href"><xsl:choose><xsl:when test="../title/text()"><xsl:text><![CDATA[#]]></xsl:text><xsl:value-of select="../title"/></xsl:when><xsl:otherwise><xsl:text/></xsl:otherwise></xsl:choose></xsl:attribute><xsl:value-of select="../title"/></xsl:element> -- <xsl:if test="count(*/section) &gt; 1"><xsl:element name="span"><xsl:element name="a"><xsl:attribute name="href">#TOC</xsl:attribute>Table
of Contents</xsl:element>-- </xsl:element></xsl:if><xsl:element name="a"><xsl:attribute name="href">#TOP</xsl:attribute>Top</xsl:element></xsl:element>
<xsl:element name="br"/>
<xsl:element name="br"/>
</xsl:element></xsl:for-each>
<xsl:element name="br"/>
</xsl:element></xsl:for-each>
<xsl:element name="div"><xsl:attribute name="class">copy</xsl:attribute><xsl:element name="sub"><xsl:value-of select="*/copyright"/></xsl:element>
</xsl:element>
</xsl:element>
</xsl:element>
</xsl:element></xsl:template></xsl:stylesheet>