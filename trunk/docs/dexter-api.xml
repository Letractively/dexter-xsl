<?xml-stylesheet href="docster.html.xsl" type="text/xsl" ?>
<doc>
    <copyright>dexter (c) 2007, 2008 Michael Dykman 
Free for use under version 2.0 of the Artistic License.     
http://www.opensource.org/licences/artistic-license.php</copyright>

  <title>The Dexter API</title>
  <author>
    <![CDATA[Michael Dykman <michael@dykman.org>]]>
  </author>
  <overview>
    <para>The internals required to create user-defined descriptors</para>
  </overview>
  <references>
    <reference>
      <title>Dexter</title>
      <summary>An introduction to dexter and it's design philosophy.</summary>
      <url>index.xml</url>
    </reference>
    <reference>
      <title>Dexter User Guide</title>
      <summary>Reference material 
      needed to use dexter and dexterity to produce XSL stylesheets</summary>
      <url>dexter-user-guide.xml</url>
    </reference>
    <reference>
      <title>Dexter API</title>
      <summary>Reference material 
      for the developer who wished to implement their own
      descriptors, editors and path macros</summary>
      <url>dexter-api.xml</url>
    </reference>
    <reference>
      <title>Javadoc</title>
      <summary>Javadoc of the dexter code base, including modules</summary>
      <url>javadoc/index.html</url>
    </reference>
  </references>

  <section>
    <title>dexter.properties</title>
    <overview><para>
	 The dexter.properties file is embedded in dexter.jar. It is through
	 this file that implementations are bound into the tools framework.
	 </para></overview>
    <chapter>
      <title>prefix</title>
      <code>
 dexter.prefix=xpl
      </code>
      <para>
      the prefix is applied to all dexter-defined attribute names 
      before scanning. it provides a pseudo-namespace to isolate 
      dexter-defined attributes from the the valid attributes of 
      the XML source. It may be redefined at need.
      </para>
    </chapter>
    <chapter>
      <title>id attributes</title>
      <code>
        <![CDATA[
 dexter.node.id=id,ID
 ]]>
      </code>
      <para>
        Some XML operations require that a document has defined id attributes. As this property is typically 
        bestowed the DTD or schema for the XML format at hand, dexter uses this alternate mechanism. Scanning
        the source document for id attributes as defined in the properties file is the first phase of dexter's 
        transformation process.
      </para>
    </chapter>

    <chapter>
      <title>editors</title>
      <code><![CDATA[
 dexter.editors=ajax
  ]]></code>
      <para>
        The second phase of the transformation process is to scan for and execute editors which are defined 
        to be active in this property. It accepts a comma-delimited list of editor names. These names, 
        prefixed with the dexterity prefix, are scanned for and
        executed as they are found. More detail about editors can be found in later chapters.
      </para>
    </chapter>

    <chapter>
      <title>descriptors</title>
      <code><![CDATA[
 dexter.descriptors=ignore,env,uniq,sub,if,case,each,ccpy,value,attr,target,ghost
      ]]></code>
      <para>
        The third phase of the transformation process is to scan for and assemble descriptors which are defined
        to be active in this property. It accepts a comma-delimited list of descriptor names. These names, 
        prefixed with the dexterity prefix, are scanned for and assembled into an execution tree. The 
        descriptors are evaluated in the same order as they are specified in this property.  
        More detail about descriptors can be found in later chapters.  And by later, I mean they aren't 
        written yet.
      </para>
    </chapter>
    <chapter>
      <title>block descriptors</title>
      <code><![CDATA[
 dexter.block=case 
 dexter.block.case=default
      ]]></code>
      <para>
        Block descriptors take some special handling at assembly time. This property directs the dexter engine 
        to treat 'case' as a block descriptor with an (always) optional terminating attribute of 'default'. 
        A block is not required to have a terminating attribute.
      </para>
    </chapter>

    <chapter>
      <title>Implementation</title>
      <code>
        <![CDATA[
 dexter.a.ajax=org.dykman.dexter.didi.AjaxAnchorEditor
 dexter.a.target=org.dykman.dexter.didi.AjaxCallerDescriptor

 dexter.a.ignore=org.dykman.dexter.dexterity.NullDescriptor 
 dexter.a.if=org.dykman.dexter.dexterity.TestDescriptor 
 dexter.a.case=org.dykman.dexter.dexterity.CaseDescriptor
 dexter.a.env=org.dykman.dexter.dexterity.EnvDescriptor 
 dexter.a.each=org.dykman.dexter.dexterity.SelectDescriptor 
 dexter.a.attr=org.dykman.dexter.dexterity.MapAttributeDescriptor 
 dexter.a.value=org.dykman.dexter.dexterity.MapNodeDescriptor
 dexter.a.ccpy=org.dykman.dexter.dexterity.CopyNodeDescriptor 
 dexter.a.sub=org.dykman.dexter.dexterity.SubdocDescriptor 
 dexter.a.uniq=org.dykman.dexter.dexterity.UniqAttrDescriptor
 dexter.a.ghost=org.dykman.dexter.dexterity.GhostDescriptor 
      ]]></code>
      <para>Each attribute is explicitly associated with it's implementing class.</para>
    </chapter>

    <chapter>
      <title>path macros</title>
      <code><![CDATA[
 dexterity.path.function.cmp-name=org.dykman.dexter.base.CompareNameFunction 
 dexterity.path.function.text=org.dykman.dexter.base.TextFunction 
 dexterity.path.function.istext=org.dykman.dexter.base.IsTextFunction
 dexterity.path.function.name=org.dykman.dexter.base.NameFunction
      ]]></code>
      <para><![CDATA[Path functions, invoked in dexter via "@!" are defined
   with the property key dexterity.path.function.<function-name>.
   ]]></para>
    </chapter>
  </section>
  <section>
    <title>Descriptors</title>
    <overview><para>
    All Descriptors discussed in this section are defined in the package org.dykman.dexter.descriptor.
    </para></overview>
      
    <chapter>
      <title>Descriptor Methods</title>
      <para>
      While Descriptors expose several methods, there are 4, the production methods,  
      which are of particular interest to the API developer.  
      </para>
      <code><![CDATA[
  public interface Descriptor
  {
    ...
    public void start();
    public void attributes();
    public void children();
    public void end();
  }
  ]]></code>
      <para>
      When a descriptor is 'run' by the TransformSequencer, each of these 4 methods are called in turn which
      push instructions back into the sequencer.
      </para>
     </chapter>
     <chapter>
      <title>Node Descriptor</title>
      <para>
      Every node in the dexter input document is automatically associated with a NodeDescriptor.  The NodeDescriptor
      describes that node to the TransformSequencer without embellishment.
      </para>
     </chapter>
     <chapter>
        <title>TransformDescriptor</title>
        <para>
    All descriptors which the user may specify on an element in a dexter source document are sub-classes of TransformDescriptor. 
	 TransformDescriptors are constructed with a reference to an inner Descriptor.
  Where multiple descriptors are specified on a given element, they are nested  with the NodeDescriptor for that element the inner-most.  
        </para>
        <para>
  Typically, a TransformDescriptor overrides one or more production methods. It may modify the attributes, replace 
  or simply dispose of the children and/or write instructions into the TransformSequencer.  
  </para>
  <para>At the lowest level, the
  TransformSequencer offers a node-level interface which allows a descriptor to directly specify XSLT productions.
  This interface is currently only used by the highly experimental didi module. 
        </para>
      </chapter>
      <chapter>
        <title>MetaDescriptor</title>
        <para>
    This is an abstract TransformDescriptor which provides a scoped-data environment during the code generation
    process.  Sub-classes use this facility to maintain the internal data paths or to pass messages to children.
        </para>
      </chapter>
      <chapter>
        <title>PathDescriptor</title>
        <para>
  The PathDescriptor is the base class of nearly every Descriptor in the dexterity module. Dexter and XSL have
  a slightly different concept of the default data axis, the PathDescriptor's primary task is to balance those
  notions. 
        </para>
      </chapter>
      <chapter>
         <title>BlockDescriptor</title>
         <para>
  The block descriptor is a special case. It encapsulates an operation which may span multiple contiguous elements.
  The handler for dexterity's 'case' attribute is the only currently implemented BlockDescriptor.
         </para>
       </chapter>
       <chapter>
         <title>Examples</title>
         <para>
  The best reference currently available for the user who wishes to implement custom descriptors is the source for the dexterity 
  descriptors.  They are generally small, single function units.  I know I need to write more about this.
  Bug me later.
         </para>
       </chapter>
     </section>
     <section>
       <title>Path Macros</title>
         <overview><para>Here are the implementation details for the user who wishes
     to extend the power of existing path syntax with user-defined path 
     macros.
         </para></overview>
       <chapter>
       <title>Path Macro Parameters</title>
         <para>
  A PathFunction is invoked by appending "@!" to a path expression, followed 
  by the name of the function and, optionally, ':' followed by an argument like so:  
         </para>
         <code><![CDATA[
  <p xplvalue="messages/*@!myfunction:argument" />
  ]]></code>
       <para>
      This expression will first evaluate the dexter path in the current context, 
      and translate it to an XPath expression appropriate to XSL's data context.
       It is important to note that, when a path macro is specified in an expression 
       without an explicit path component, the default path of '.' is explicitly set
       before the path macro is invoked.  If no argument is specified via ':', the value of
       arg will be null. If ':' is specified in the expression but there are no trailing 
       characters, then 'arg' will be set to the empty string.
       </para>
         <para>
  The 'path' parameter will be the translated XPath expression. 
  The 'arg' parameter will be the value to the right of the 
  semi-colon ':', if any.  If no argument is provided, 'arg' will 
  be null. If the semi-colon is present but followed by no trailing characters.
  'arg' will be assigned the empty string  
         </para>
         <para>
   The result of the expression must be a string representing a
   discrete XPath expression. 
         </para>
         <code><![CDATA[
  // from NameFunction 
  public String apply(String path, String arg)
  {
    StringBuffer sb = new StringBuffer();
    sb.append("local-name(").append(path).append(")");
    return sb.toString(); 
  }
       ]]></code>
       </chapter>
       <chapter>
       
         <title>Simple Path Macros</title>
         <para><![CDATA[
     All of the path macros implemented in dexter's default configuration are 
     simple path macros. They are created by defining a property keyed by 
     dexter.macro.def.<funcname> with a simple format string for a value.
     Two variables are pre-defined in the format string, $path and $arg.  
     The rest is interpreted as literal text. 
         ]]></para>
         <code><![CDATA[
#simple path macros
dexterity.macro.def.cmp-name=local-name($path)="$arg"
dexterity.macro.def.text=$path/text()
dexterity.macro.def.istext=$path/self::text()
dexterity.macro.def.name=local-name($path)
dexterity.macro.def.trim=normalize-space($path)
dexterity.macro.def.count=count($path)
dexterity.macro.def.pos=position()
         ]]></code>
         <title>The PathFunction Interface</title>
         <para><![CDATA[
         Should the simple path macro fail to provide the level of control your expression
         requires, it is a trivial task to implement the interface directly. A property keyed by 
          dexter.macro.def.<funcname> may then be specified with the fully qualified class
          name of the implementation.   
         ]]></para>
         <code><![CDATA[
  public interface PathFunction
  {
    public String apply(String path,String arg);
  }
         ]]></code>
       </chapter>
  </section>
  <section>
    <title>Editors</title>
    <overview><para>Editors logically modify the source
  document before it is extracted to XML.</para></overview>
    <chapter>
      <title>Output Domain</title>
      <para>As editors are designed to modify the input document, they typically
      need to contain domains-specific knowledge of the target XML format. It is
      not really possible for editors to be XML-agnostic, as is required for membership
      is the dexterity base module.
      </para>
      <para>
      Editors are created by sub-classing org.dykman.dexter.base.AbstractDocumentEditor. 
      </para>      
      <para> 
  Editors may influence XSL transforms to generate
  invalid result documents from valid source files.  Much care must be taken
  when implementing editors to make sure that our actions are valid in the
  context of the output document.   
      </para>
      <para>
  The only editor implementations in this release are confined to the experimental
  didi module which is responsible for all XHTML-specific functions.
      </para>
    </chapter>
  </section>
  <section>
  <title>Embedding Dexter</title>
  <overview>
  </overview>
  <chapter>
  <title>The Dexter Object</title>
  <code><![CDATA[
  import org.dykman.dexter.Dexter;

  // uses the built in properties in org/dykman/dexter/dexter.properties
  Dexter dexter = new Dexter("UTF-8");
  // an alternative allows to user to specify custom properties
  // Dexter dexter = new Dexter("UTF-8",my-properties);

  dexter.setMediaType("text/html");
  dexter.setMethod("html");
  dexter.setIndent(true);
  ]]></code>
  <para>
  The Dexter object is created with a specified content-encoding and,
  optionally, a set of properties.  If properties are not specified,
  the built-in properties will be used. Only the UTF-8 character
  encoding has been explored so far.  The output 
  attributes which are demonstrated in the example are the default 
  values.  As in XSL, method may be one of "xml", "html" or "text".  
  MediaType may be any mime-type consistent with your source/result
  XML type.  These settings are passed along directly to the XSL 
  document; they do not influence dexter's behavior. 
  </para>
  <para><![CDATA[
  org.w3c.xml.Document objects with a DocType of XSLT are produced
  by passing org.w3c.xml.Document objects of any DocType to the method
  generateXSLT(Document source).  The result is typed Map<String,Document>
  which will always contain at least one entry. This method does not 
  create documents on disk.  When used at the command line, dexter uses an
  internal method which invokes a null transform.in order to output
  it to a stream.  If you have a means of providing prettier output, 
  go for it.
  ]]>
  </para>
  <code><![CDATA[
	Map<String, Document> results = dexter.generateXSLT(inputDocument);
  ]]></code>
  </chapter>
  </section>
 </doc>
