<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
		"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- 
Examples of the data document may be found at

http://dexter-xsl.googlecode.com/svn/trunk/docs/index.xml
http://dexter-xsl.googlecode.com/svn/trunk/docs/dexter-api.xml
http://dexter-xsl.googlecode.com/svn/trunk/docs/dexter-user-guide.xml
http://dexter-xsl.googlecode.com/svn/trunk/docs/case-for-xsl.xml

There XML document form the core of dexter's documentation.  They can viewed in your
web browsers styled by the XSLT generated by this source document.

A quick and dirty skeleton of the data format is shown below
for quick reference
<doc>
    <copyright>(c) 2008</copyright>

	<title>A Title</title>
	<subtitle>The Whole Story</subtitle>
	<author>Some Guy</author>
	<overview>
		<para>document overview text.</para>
		...
	</overview>
	<references>
   		<reference>
     			<title>name of external doc</title>
     			<summary>summary of external doc</summary>
     			<url>index.xml</url>
   		</reference>
   		...
	</references>
	<section>
		<title>Section Title</title>
		<overview>
			<para>section overview text</para>
			...
		</overview>

		<chapter>
			<title>chapter title</title>
			<para>
			Lorem ipsum <link url="http://www.cicero.spqr">dolor</link> sit amet
				...
			</para>
			<code><![CDATA[a possibly multi-line code fragment, CDATA is for conveninece
			and is not required ]]>
			</code>
		</chapter>
		...
	</section>
	...
	
<doc>
-->

<!--
An XSLT stylesheet is generated with the command   
    $ dexter.sh docster.html
 -->
<!-- 
declare dexter-related attributes in their default namespace..  
dexter does not care is you do so or not, but it will in any case
prevent them from being reflected in generated code.  

NOTE: if you use an alternate namespace, you must set a property at the 
command line through by specifying an option:
    $ dexter.sh -d=dexterity.namespace=myns input.html ...
    
Refer to the README for information on running dexter in your environment
 -->
<html
	xmlns:dx="http://dexter-xsl.googlecode.com/svn/trunk/schema/dexterity-1.0.xsd"
	xmlns:dd="http://dexter-xsl.googlecode.com/svn/trunk/schema/didi-1.0.xsd">
<head>
<style type="text/css">
@import url("style.css");
</style>
<!--
  intial context is '/'
  
  dx:value
  replace the content of the 'title' tag with the text content of */title 
  from the data document

  REMEMBER: all path expressions refer to the data document, not to nodes within 
  this document.  
 -->
<title dx:value="*/title">Document Title</title>
<!--
  dd:meta
  replace the current tag with a set of meta tags derived from data in the file dexter.meta
  which can be seen at http://dexter-xsl.googlecode.com/svn/trunk/docs/dexter.meta
 -->
<meta name="author" content="some guy" dd:meta="dexter.meta" />
</head>
<body>
<div class="foo"><span> <a name="TOP"></a></span>
<div>
<!--
  dx:value
  replace the content of the 'title' tag with the text content of */title 
  from the data document 
 -->
<h1 dx:value="*/title">Document Title</h1>
<!--
  dx:if
  if a node is found at the path */subtitle in the data document,
  	replace the content of <h5> with the text content of */subtitle
  if no node is found in the data document, this node will not be rendered 
 -->
<h5 dx:if="*/subtitle" dx:value="*/subtitle">Sub-Title</h5>
</div>

<div style="float: right; width: 35%">
<div style="clear: both; align: left; width: 100%;">

<span class="author" style="width: 100% align : left;">author:
<!-- 
  dx:ghost
  remove the current element from output while performing all operations 
  attached to that element. 
  
  The following expression will evaluate the dx:value expression, inserting
  the text value of */author from the data document while suppressing the span
  element which it is contained in
 --> 
<span dx:ghost="" dx:value="*/author">Author Name</span>
</span></div>
<br />

<!-- 
 dx:each
  iterate over the current element for each node found in the expression.
  this has the additional effect of setting the path context.
  
  in this case, it will generate a div for each element found in the data document
  at the path /*/references/reference. 
  relative path expressions encountered within this element  or it's children will be
  evaluated in the context /*/references/reference
  For example, the path expression 'title' in this context is treated as
  the title element of the current reference element.
 --> 
 
<div style="clear: both;" dx:each="*/references/reference">
<div style="padding-left: 5px; left-margin: 5px;">
<!--
  dx:attr
  rewrite an attribute values on the current node
  
  here, we render the text context of the url element of
  the current reference element as the value of the href attribute
  while replacing the content of the element with the text context of
  the title element of the current reference 
 -->	
<a href="#" dx:attr="href:url" dx:value="title">external title</a><br />

<div style="left-margin: 5px;" dx:value="summary">this is a
document summary; typically, a short paragraph</div>
</div>
</div>
<!-- end of each -->


<!--
  dx:ignore
  ignore the current node and any embedded operations.
   
  this node is retained in the document for cosmetic purposes as 
  an example
  of what more than one reference looks like when viewed directly in a web browser.
  It is completely ignored during XSL generation, as the preceeding dx:each 
  descriptor will handle all reference nodes in the data document  
 -->
<div dx:ignore="" style="clear: both;">
<div style="padding-left: 5px; left-margin: 5px;"><a href="#">external
title</a><br />
<div style="left-margin: 5px;">this is a document summary;
typically, a short paragraph</div>
</div>
</div>


</div>

<div style="float: left; width: 55%">

<!--
  dx:env
  set the context path for the scope of this element while performing 
  no operation 
 -->
<div dx:env="*/overview" style="float: left; clear: both;">
<h2 width="100%">Overview</h2>
<p>
<!--
   each para in */overview 
 -->
<i dx:each="para" dx:value=".">document overview text</i>

</p>
</div>
<!-- end dx:env -->

<!--
  the path macro morethan is a core path macro.  it is defined in
  dexter.properties as

		dexter.macro.morethan=count($path) > $arg
 
  therefore the expression 
  
  		*/section@!morethan:1
  
  as used in the following dx:if descriptor is translated into the 
  XPATH expression:
  
  		count(*/section) > 1
  		
  	As applied here, it means that the table of contents will only be rendered if the 
  	data document has more than 
  	one section.
  	 
 -->
<div dx:if="*/section@!morethan:1" style="top-margin: 15px;">
<h2>Table of Contents</h2>
<a name="TOC"></a>
<!--
  note the '#' sign at the start of the expression in dx:each.  it is used as 
  the child operator. instead of rendering a div for each section found in
  the data document, we wish to render one <div> and 
  evaluate it's children for each section. 

  the expression in dx:attr is an example of a compound expression where
  elements between the braces { } are treated as data paths and elements
  outside the braces are treated as literal.  Here it is used to 
  generate a table of contents with links to thier respect sections.
  The # sign in the context of the dx:attr descriptor, has no special meaning 
  and is interpreted literally.

 -->
<div dx:each="#*/section" style="left-margin: 30px;"><a
	dx:attr="href:#{title}" dx:value="title">Section Title</a><br />
</div>
</div>
<!-- end dx:if -->

</div>

</div>

<div style="clear: both">
<!--
create a div for each section, setting the context path 
 -->
<div dx:each="*/section"><a name="tagname" dx:attr="name:{title}"></a>

<h2 dx:value="title" width="80%">Section Title</h2>

<!--
now render each para found in the section/overview
inside a single div
 -->
<div width="60%" dx:if="overview" dx:each="#overview/para">
<p><i dx:value=".">section overview paragraph 1</i></p>
<p dx:ignore=""><i>section overview paragraph 2</i></p>
</div>

<!-- 
  create one <div> to contain a list of lniks to chapters
  within the current section
-->
<div dx:each="#chapter" class="listing"><a
	dx:attr="href:#{../title}-{title}">&gt; <span dx:ghost=""
	dx:value="title">Chapter Title</span></a><br />
</div>
<a href="#TOC">&lt;&lt; Table of Contents</a><br />
<a href="#TOP">&lt;&lt; Top</a><br />

<!--
  now we render each chapter in the section, setting the context path. 
 -->
<div dx:each="chapter" class="section">
<!--
   here we used the compound attribute to build the target for chapter links
   by explicitly defining the name attribute 
 -->
<a name="tagname"
	dx:attr="name:{../title}-{title}"></a>
<h3 dx:value="title">chapter title</h3>

<!--
create a div and evlauate it's children node returned by the path expression
under the current path context; translates to  /*/section/chapter/*
which will only return element children of chapter, text and comments are ignored
in this expression/  
 -->
<div dx:each="#*">
<!--
	dx:case
	similar to if, but expressions are evaluated in a chain of contiguous 
	tagged elements, evalauating the first node the for which the expression
	tests true.
	in this case, the expression @para will be true if the current data element
	in the iteration is <para>. The next contiguous node in this chain tests 
	for the data element <code>  
	
	the dx:each expression is evaluated in the context of the para node.
	With various nested dx:each expressions, the effective path within this
	tag and it's children is */section/chapter/para.  Both <link> elements
	and text nodes will be combined into a single cursor which will
	return the set of these nodes in document order.  It is by this mechanism that 
	link tags may be intermingled with raw text.
 -->
<p dx:case="@para" dx:each="#link|@!text">
<!-- an nested case..  the path expression return true if the current node is a text
node, in which case dx:value is applied replacing the content of this element
with the text node from the data document 
 -->
<span dx:case="@!istext"
	dx:ghost="" dx:value="."> Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Nam elit massa, volutpat pulvinar,
pellentesque nec, bibendum vitae, tortor. Praesent congue. Donec lorem.
Morbi elementum, metus in adipiscing molestie, est lacus blandit erat,
malesuada dignissim orci urna vel nunc. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Nulla sit amet odio vitae nunc bibendum
dignissim. Maecenas pellentesque aliquam eros. Duis in ipsum sed lectus
mollis lacinia. Pellentesque habitant morbi tristique senectus et netus
et malesuada fames ac turpis egestas. Curabitur id urna vel nisi mollis
facilisis. Morbi ac erat. Sed bibendum dolor non sem. Cras velit risus,
pellentesque vitae, tristique a, tincidunt at, leo. Donec at velit.
Mauris ullamcorper. Aliquam erat volutpat. </span>
<!-- end dx:case=@!istext -->

<!-- test if it's named 'link' -->
<a dx:case="@link" href="extern" dx:attr="href::url" dx:value=".">links to something</a> 

<!-- 
   no dx:case or dx:default found in the next element so the inner case block
   is terminated
 -->
<span dx:ignore=""> Praesent felis neque, consectetuer nec,
ullamcorper sed, lobortis id, ipsum. Quisque commodo commodo nisi.
Mauris urna elit, laoreet sed, interdum at, ornare a, nunc. Duis
pharetra mattis nisi. Aenean tristique. Aliquam vel tortor. Sed tempus
blandit ipsum. Nullam vel nisl id eros laoreet lobortis. Cum sociis
natoque penatibus et magnis dis parturient montes, nascetur ridiculus
mus. Nunc ut leo et massa tempor vehicula. Ut ultrices, felis nec
pretium tristique, risus diam pellentesque velit, in imperdiet diam diam
quis sem. Proin eget velit sit amet diam facilisis suscipit. </span></p>
<!-- end dx:case=@para -->

<!-- second case for outer case block..  render elements names 'code' -->
<div dx:case="@code"><pre dx:value="." style="width: 80%;">
    
     // a code example
     foo.bar('foobar');
    </pre>
</div>
</div>
<!-- outer case chain terminates for want of a continuation.
if dx:default had been specified, it would be invoked to handle any node 
not handled by the cases in the dx:case chain. In the absence of one, no 
output will be produced.
 -->

<div style="text-align: center"><a href="#"
	dx:attr="href:#{../title}"><span dx:ghost="" dx:value="../title">Section
Title</span></a> -- <span dx:if="*/section@!morethan:1"><a href="#TOC">Table
of Contents</a>-- </span><a href="#TOP">Top</a></div>
<br />
<br />
</div>
<br />
</div>
<div class="copy"><sub dx:value="*/copyright">copyright info</sub>
</div>
</div>
</body>
</html>
